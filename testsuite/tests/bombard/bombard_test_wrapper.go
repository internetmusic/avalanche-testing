package bombard

import (
	"strconv"
	"time"

	"github.com/kurtosis-tech/kurtosis-go/lib/networks"
	"github.com/kurtosis-tech/kurtosis-go/lib/testsuite"

	avalancheNetwork "github.com/ava-labs/avalanche-testing/avalanche/networks"
	avalancheService "github.com/ava-labs/avalanche-testing/avalanche/services"
	"github.com/ava-labs/avalanche-testing/testsuite/tester"
	"github.com/palantir/stacktrace"
	"github.com/sirupsen/logrus"
)

const (
	normalNodeConfigID       networks.ConfigurationID = "normal-config"
	additionalNode1ServiceID networks.ServiceID       = "additional-node-1"
	additionalNode2ServiceID networks.ServiceID       = "additional-node-2"
)

// StakingNetworkRunAndBootstrapTest is a standard test for executing a configurable
// Avalanche Test and then bootstrapping two additional nodes to ensure the data
// generated by the tests can be bootstrapped correctly.
type StakingNetworkRunAndBootstrapTest struct {
	ImageName        string
	TxFee            uint64
	ExecutionTimeout time.Duration
	ShortEpochs      bool

	testExecutor tester.AvalancheConfigurableTester
}

// NewBombardXChainTest returns a Kurtosis Test that bombards each of five clients on the network with [numTxs]
func NewBombardXChainTest(imageName string, executionTimeout time.Duration, numTxs, txFee uint64, acceptanceTimeout time.Duration, shortEpochs bool) testsuite.Test {
	return &StakingNetworkRunAndBootstrapTest{
		ImageName:        imageName,
		ExecutionTimeout: executionTimeout,
		TxFee:            txFee,
		ShortEpochs:      shortEpochs,
		testExecutor:     NewBombardExecutor(numTxs, txFee, acceptanceTimeout),
	}
}

// NewBombardXChainWithIndependentTxsTest returns a Kurtosis Test that bombards each of five clients on the network with [numTxs] that are not interdependent
func NewBombardXChainWithIndependentTxsTest(imageName string, executionTimeout time.Duration, numTxs, txFee uint64, acceptanceTimeout time.Duration, shortEpochs bool) testsuite.Test {
	return &StakingNetworkRunAndBootstrapTest{
		ImageName:        imageName,
		ExecutionTimeout: executionTimeout,
		TxFee:            txFee,
		ShortEpochs:      shortEpochs,
		testExecutor:     NewBombardIndependentTxsExecutor(numTxs, txFee, acceptanceTimeout),
	}
}

// Run implements the Kurtosis Test interface
func (test StakingNetworkRunAndBootstrapTest) Run(network networks.Network, context testsuite.TestContext) {
	castedNetwork := network.(avalancheNetwork.TestAvalancheNetwork)
	bootServiceIDs := castedNetwork.GetAllBootServiceIDs()
	clients := make([]*avalancheService.Client, 0, len(bootServiceIDs))
	for serviceID := range bootServiceIDs {
		avalancheClient, err := castedNetwork.GetAvalancheClient(serviceID)
		if err != nil {
			context.Fatal(stacktrace.Propagate(err, "Failed to get Avalanche Client for boot node with serviceID: %s.", serviceID))
		}
		clients = append(clients, avalancheClient)
	}

	// Execute the bombard test to issue [NumTxs] to each node
	if err := test.testExecutor.SetClients(clients); err != nil {
		context.Fatal(stacktrace.Propagate(err, "Failed to set clients on test executor."))
	}

	logrus.Infof("Executing test...")
	if err := test.testExecutor.ExecuteTest(); err != nil {
		context.Fatal(stacktrace.Propagate(err, "Bombard Test Failed."))
	}

	logrus.Infof("Test execution completed successfully.")
	logrus.Infof("Adding two additional nodes and waiting for them to bootstrap...")
	// Add two additional nodes to ensure that they can successfully bootstrap the additional data
	availabilityChecker1, err := castedNetwork.AddService(normalNodeConfigID, additionalNode1ServiceID)
	if err != nil {
		context.Fatal(stacktrace.Propagate(err, "Failed to add %s to the network.", additionalNode1ServiceID))
	}
	availabilityChecker2, err := castedNetwork.AddService(normalNodeConfigID, additionalNode2ServiceID)
	if err != nil {
		context.Fatal(stacktrace.Propagate(err, "Failed to add %s to the network.", additionalNode2ServiceID))
	}

	// Wait for the nodes to finish bootstrapping
	if err = availabilityChecker1.WaitForStartup(); err != nil {
		context.Fatal(stacktrace.Propagate(err, "Failed to wait for startup of %s.", additionalNode1ServiceID))
	}
	logrus.Infof("Node1 finished bootstrapping.")
	if err = availabilityChecker2.WaitForStartup(); err != nil {
		context.Fatal(stacktrace.Propagate(err, "Failed to wait for startup of %s.", additionalNode2ServiceID))
	}
	logrus.Infof("Node2 finished bootstrapping.")
}

// GetNetworkLoader implements the Kurtosis Test interface
func (test StakingNetworkRunAndBootstrapTest) GetNetworkLoader() (networks.NetworkLoader, error) {
	// Add config for a normal node, to add an additional node during the test
	desiredServices := make(map[networks.ServiceID]networks.ConfigurationID)
	serviceConfigs := make(map[networks.ConfigurationID]avalancheNetwork.TestAvalancheNetworkServiceConfig)
	normalServiceConfig := avalancheNetwork.NewDefaultAvalancheNetworkServiceConfig(test.ImageName)

	if !test.ShortEpochs {
		serviceConfigs[normalNodeConfigID] = *normalServiceConfig
		return avalancheNetwork.NewDefaultAvalancheNetworkLoader(
			true,                 // Staking network
			test.TxFee,           // Network wide transaction fee
			*normalServiceConfig, // Config for the bootstrap nodes
			serviceConfigs,       // Service Configurations
			desiredServices,      // Services to start on network configuration
		)
	}

	normalEpochStartTime := time.Now().Unix() - 100
	laggingEpochStartTime := normalEpochStartTime + 3
	aheadEpochStartTime := normalEpochStartTime - 3

	normalServiceConfig.SetCLIArgs(map[string]string{
		"snow-epoch-first-transition": strconv.Itoa(int(normalEpochStartTime)),
		"snow-epoch-duration":         "10s",
	})
	middleConfig := normalServiceConfig

	laggingConfig := avalancheNetwork.NewDefaultAvalancheNetworkServiceConfig(test.ImageName)
	laggingConfig.SetCLIArgs(map[string]string{
		"snow-epoch-first-transition": strconv.Itoa(int(laggingEpochStartTime)),
		"snow-epoch-duration":         "10s",
	})

	aheadConfig := avalancheNetwork.NewDefaultAvalancheNetworkServiceConfig(test.ImageName)
	aheadConfig.SetCLIArgs(map[string]string{
		"snow-epoch-first-transition": strconv.Itoa(int(aheadEpochStartTime)),
		"snow-epoch-duration":         "10s",
	})

	serviceConfigs[normalNodeConfigID] = *middleConfig

	return avalancheNetwork.NewCustomBootstrapsAvalancheNetworkLoader(
		true,
		test.TxFee,
		[]avalancheNetwork.TestAvalancheNetworkServiceConfig{
			*middleConfig,
			*middleConfig,
			*middleConfig,
			*laggingConfig,
			*aheadConfig,
		},
		serviceConfigs,
		desiredServices,
	)
}

// GetExecutionTimeout implements the Kurtosis Test interface
func (test StakingNetworkRunAndBootstrapTest) GetExecutionTimeout() time.Duration {
	return test.ExecutionTimeout
}

// GetSetupBuffer implements the Kurtosis Test interface
func (test StakingNetworkRunAndBootstrapTest) GetSetupBuffer() time.Duration {
	return 2 * time.Minute
}
